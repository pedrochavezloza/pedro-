(function () {
'use strict';

const PREFIXES = [
	'',
	'moz',
	'webkit',
	'ms'
];

/*============================ zQ Functions =======================*/
class zQ {
	constructor(selector, parent = document) {
		this.results = [];
		try {
			if (typeof selector === 'string') {
				this.results = Array.from(parent.querySelectorAll(selector));
				if (parent instanceof HTMLElement && parent.matches(selector)) {
					this.results.push(parent);
				}
			} else if (selector instanceof NodeList || selector instanceof HTMLCollection) {
				this.results = Array.from(selector);
			} else if (selector instanceof Array) {
				this.results = selector;
			} else if (typeof selector === 'object') {
				this.results = [selector];
			} else {
				throw new TypeError(`Expected a string or NodeList but got a ${typeof selector}: ${selector}.`);
			}
			this.query = selector || ':root';
		} catch (error) {
			console.error(error);
		}
	}

	get length() {
		return this.results.length;
	}

	get found() {
		return this.length !== 0;
	}

	async text(str) {
		return this.each(node => node.textContent = str);
	}

	async html(html) {
		return this.each(node => node.innerHTML = html);
	}

	async replaceText(replacements = {}) {
		return this.each(el => Object.keys(replacements).forEach(find => {
			el.textContent = el.textContent.replace(find, replacements[find]);
		}));
	}

	toString() {
		return this.query;
	}

	item(n) {
		return this.results[n];
	}

	*values() {
		for (let item of this.results) {
			yield item;
		}
	}

	*keys() {
		for (let n = 0; n < this.length; n++) {
			yield n;
		}
	}

	*entries() {
		let n = 0;
		for (const node of this) {
			yield [n++, node];
		}
	}

	[Symbol.iterator]() {
		return this.values();
	}

	async visible() {
		return this.css({visibility: 'visible'});
	}

	async invisible() {
		return this.css({visibility: 'hidden'});
	}

	async forEach(...args) {
		return this.each(...args);
	}

	async has(node) {
		return [...this].includes(node);
	}

	async each(callback) {
		[...this].forEach(callback);
		return this;
	}

	/**
	 * Note: This is for `HTMLDialogElement.prototype.show`, not the inverse
	 * of `hide`
	 */
	async show() {
		return this.each(node => {
			if ('show' in node) {
				node.show();
			}
		});
	}

	async showModal() {
		return this.each(node => {
			if ('showModal' in node) {
				node.showModal();
			}
		});
	}

	async close() {
		return this.each(node => {
			if ('close' in node) {
				node.close();
			}
		});
	}

	async animate(keyframes, opts = 400) {
		if ('animate' in Element.prototype) {
			return Promise.all(await this.map(node => {
				return new Promise((resolve, reject) => {
					const anim = node.animate(keyframes, opts);
					anim.onfinish = () => resolve(node);
					anim.oncancel = reject;
				});
			})).then(els => new zQ(els));
		} else {
			return Promise.resolve([]);
		}
	}

	async getAnimations() {
		let anims = [];
		await this.each(el => {
			const elAnims = el.getAnimations();
			anims = anims.concat(elAnims);
		});
		return anims;
	}

	async playAnimations(...ids) {
		let anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.play());
		return this;
	}

	async pauseAnimations(...ids) {
		let anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.pause());
		return this;
	}

	async cancelAnimations(...ids) {
		const anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.cancel());
		return this;
	}

	async animateFilter({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 'none',
		to         = 'none',
		id         = 'grayscale',
	} = {}) {
		return this.animate([
			{filter: `${from}`},
			{filter: `${to}`},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterDropShadow({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0 0 0 black',
		to         = '0.5em 0.5em 0.5em rgba(0,0,0,0.3)',
		id         = 'drop-shadow',
	} = {}) {
		return this.animate([
			{filter: `drop-shadow(${from})`},
			{filter: `drop-shadow(${to})`},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterGrayscale({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'grayscale',
	} = {}) {
		return this.animateFilter({
			from: `grayscale(${from})`,
			to: `grayscale(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterBlur({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0px',
		to         = '5px',
		id         = 'blur',
	} = {}) {
		return this.animateFilter({
			from: `blur(${from})`,
			to: `blur(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterInvert({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = '100%',
		id         = 'invert',
	} = {}) {
		return this.animateFilter({
			from: `invert(${from})`,
			to: `invert(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterHueRotate({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0deg',
		to         = '90deg',
		id         = 'hue-rotate',
	} = {}) {
		return this.animateFilter({
			from: `hue-rotate(${from})`,
			to: `hue-rotate(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterBrightness({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'brightness',
	} = {}) {
		return this.animateFilter({
			from: `brightness(${from})`,
			to: `brightness(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterContrast({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'contrast',
	} = {}) {
		return this.animateFilter({
			from: `contrast(${from})`,
			to: `contrast(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterSaturate({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'saturate',
	} = {}) {
		return this.animateFilter({
			from: `saturate(${from})`,
			to: `saturate(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterOpacity({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'saturate',
	} = {}) {
		return this.animateFilter({
			from: `opacity(${from})`,
			to: `opacity(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterSepia({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'sepia',
	} = {}) {
		return this.animateFilter({
			from: `sepia(${from})`,
			to: `sepia(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async fade({
		duration   = 400,
		delay      = 0,
		fill       = 'forwards',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 1,
		to         = 0,
		id         = 'fade-in',
	} = {}) {
		return this.animate([
			{opacity: from},
			{opacity: to}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async fadeIn({
		duration   = 400,
		delay      = 0,
		fill       = 'forwards',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'fade-in',
	} = {}) {
		return this.fade({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			from,
			to,
			id,
		});
	}

	async fadeOut(opts = {}) {
		return this.fade(opts);
	}

	async scale({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'scale',
		initialScale = 0,
		scale        = 1.5,
	} = {}) {
		return this.animate([
			{transform: `scale(${initialScale})`},
			{transform: `scale(${scale})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async grow({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'grow',
		initialScale = 0,
		scale        = 1,
	} = {}) {
		return this.scale({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
			scale,
			initialScale,
		});
	}

	async shrink({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'shrink',
		initialScale = 1,
		scale        = 0,
	} = {}) {
		return this.scale({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
			scale,
			initialScale,
		});
	}

	async rotate({
		duration        = 400,
		delay           = 0,
		fill            = 'both',
		direction       = 'normal',
		easing          = 'linear',
		iterations      = 1,
		id              = 'rotate',
		rotation        = '1turn',
		initialRotation = '0turn',
	} = {}) {
		return this.animate([
			{transform: `rotate(${initialRotation})`},
			{transform: `rotate(${rotation})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async bounce({
		duration   = 400,
		delay      = 0,
		fill       = 'none',
		direction  = 'alternate',
		easing     = 'ease-in-out',
		iterations = 1,
		id         = 'bounce',
		height     = '-50px',
	} = {}) {
		return this.animate([
			{transform: 'none'},
			{transform: `translateY(${height})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async shake({
		duration   = 400,
		delay      = 0,
		fill       = 'none',
		direction  = 'alternate',
		easing     = 'cubic-bezier(.68,-0.55,.27,1.55)',
		iterations = 6,
		id         = 'shake',
		offsetX    = '60px',
		offsetY    = '20px',
		scale      = 0.9,
	} = {}) {
		return this.animate([
			{transform: 'none'},
			{transform: `translateY(${offsetY}) translateX(-${offsetX}) scale(${scale})`},
			{transform: 'none'},
			{transform: `translateY(-${offsetY}) translateX(${offsetX}) scale(${1/scale})`},
			{transform: 'none'},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideLeft({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-left',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateX(${initial})`},
			{transform: `translateX(-${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideRight({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-right',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateX(${initial})`},
			{transform: `translateX(${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideUp({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-up',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateY(${initial})`},
			{transform: `translateY(-${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideDown({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-down',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateY(${initial})`},
			{transform: `translateY(${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async loadHTML(href) {
		const url = new URL(href, location.origin);
		const resp = await fetch(url);

		if (resp.ok) {
			const parser = new DOMParser();
			const html = await resp.text();
			const doc = parser.parseFromString(html, 'text/html');
			this.html(doc.body.innerHTML);
			return this;
		} else {
			throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
		}
	}

	async some(callback) {
		return [...this].some(callback);
	}

	async every(callback) {
		return [...this].every(callback);
	}

	async find(callback) {
		return [...this].find(callback);
	}

	async findAll(callback) {
		return this.filter(callback);
	}

	async map(callback) {
		return [...this].map(callback);
	}

	async filter(callback) {
		return new zQ([...this].filter(callback));
	}

	async addClass(...classes) {
		return this.each(el => el.classList.add(...classes));
	}

	async removeClass(...classes) {
		return this.each(el => el.classList.remove(...classes));
	}

	async hasClass(cname) {
		return this.some(el => el.classList.contains(cname));
	}

	async toggleClass(cname, force) {
		if (typeof force !== 'undefined') {
			return this.each(node => node.classList.toggle(cname, force));
		} else {
			return this.each(node => node.classList.toggle(cname));
		}
	}

	async replaceClass(cname1, cname2) {
		this.each(node => node.classList.replace(cname1, cname2));
		return this;
	}

	async pickClass(cname1, cname2, condition) {
		this.toggleClass(cname1, condition);
		this.toggleClass(cname2, ! condition);
		return this;
	}

	async remove() {
		this.each(el => el.remove());
		return this;
	}

	async empty(query = null) {
		if (typeof query === 'string') {
			this.each(node => [...node.children].forEach(child => {
				if (child.matches(query)) {
					child.remove();
				}
			}));
		} else {
			this.each(node => [...node.children].forEach(child => child.remove()));
		}
		return this;
	}

	async hide(hidden = true) {
		return this.each(el => el.hidden = hidden);
	}

	async unhide(shown = true) {
		return this.hide(! shown);
	}

	async append(...nodes) {
		return this.each(el => el.append(...nodes));
	}

	async prepend(...nodes) {
		return this.each(el => el.prepend(...nodes));
	}

	async before(...nodes) {
		return this.each(el => el.before(...nodes));
	}

	async after(...nodes) {
		return this.each(el => el.after(...nodes));
	}

	async afterBegin(text) {
		return this.each(el => el.insertAdjacentHTML('afterbegin', text));
	}

	async afterEnd(text) {
		return this.each(el => el.insertAdjacentHTML('afterend', text));
	}

	async beforeBegin(text) {
		return this.each(el => el.insertAdjacentHTML('beforebegin', text));
	}

	async beforeEnd(text) {
		return this.each(el => el.insertAdjacentHTML('beforeend', text));
	}

	async hasAttribute(attr) {
		return this.some(el => el.hasAttribute(attr));
	}

	async attr(attrs = {}) {
		return this.each(node => {
			for (const [key, value] of Object.entries(attrs)) {
				switch (typeof(value)) {
				case 'string':
				case 'number':
					node.setAttribute(key, value);
					break;
				case 'boolean':
					value ? node.setAttribute(key, '') : node.removeAttribute(key);
					break;
				default:
					node.removeAttribute(key);
				}
			}
		});
	}

	async data(props = {}) {
		return this.each(node => {
			for (const [key, value] of Object.entries(props)) {
				if (value === false) {
					delete node.dataset[key];
				} else if (value === true || value === null) {
					node.dataset[key] = '';
				} else {
					node.dataset[key] = typeof(value) === 'string' ? value : JSON.stringify(value);
				}
			}
		});
	}

	async pause() {
		return this.each(media => media.pause());
	}

	/*==================== Listener Functions =================================*/
	async on(event, callback, ...args) {
		this.each(node => node.addEventListener(event, callback, ...args));
		return this;
	}

	async once(event, callback) {
		return this.on(event, callback, {once: true});
	}

	async off(event, callback) {
		return this.each(node => node.removeEventListener(callback));
	}

	async ready(callback, ...args) {
		this.on('DOMContentLoaded', callback, ...args);
		if (document.readyState !== 'loading') {
			this.each(node => {
				callback.bind(node)(new Event('DOMContentLoaded'));
			}, false);
		}
		return this;
	}

	async networkChange(callback, ...args) {
		return this.online(callback, ...args).offline(callback, ...args);
	}

	async playing(callback) {
		return this.each(e => e.onplay = callback);
	}

	async paused(callback) {
		this.each(e => e.onpause = callback, false);
		return this;
	}

	async visibilitychange(callback, ...args) {
		this.each(e => {
			PREFIXES.forEach(pre => {
				e.addEventListener(`${pre}visibilitychange`, callback, ...args);
			});
		}, false);
		return this;
	}

	async click(callback, ...args) {
		return this.on('click', callback, ...args);
	}

	async dblclick(callback, ...args) {
		this.on('dblclick', callback, ...args);
	}

	async contextmenu(callback, ...args) {
		return this.on('contextmenu', callback, ...args);
	}

	async keypress(callback, ...args) {
		return this.on('keypress', callback, ...args);
	}

	async keyup(callback, ...args) {
		return this.on('keyup', callback, ...args);
	}

	async keydown(callback, ...args) {
		return this.on('keydown', ...args);
	}

	async mouseenter(callback, ...args) {
		return this.on('mouseenter', callback, ...args);
	}

	async mouseleave(callback, ...args) {
		return this.on('mouseleave', callback, ...args);
	}

	async mouseover(callback, ...args) {
		return this.on('mouseover', callback, ...args);
	}

	async mouseout(callback, ...args) {
		return this.on('mouseout', callback, ...args);
	}

	async mousemove(callback, ...args) {
		return this.on('mousemove', callback, ...args);
	}

	async mousedown(callback, ...args) {
		return this.on('mousedown', callback, ...args);
	}

	async mouseup(callback, ...args) {
		return this.on('mouseup', callback, ...args);
	}

	async input(callback, ...args) {
		return this.on('input', callback, ...args);
	}

	async change(callback, ...args) {
		return this.on('change', callback, ...args);
	}

	async submit(callback, ...args) {
		return this.on('submit', callback, ...args);
	}

	async reset(callback, ...args) {
		return this.on('reset', callback, ...args);
	}

	async invalid(callback, ...args) {
		return this.on('invalid', callback, ...args);
	}

	async select(callback, ...args) {
		return this.on('select', callback, ...args);
	}

	async focus(callback, ...args) {
		return this.on('focus', callback, ...args);
	}

	async blur(callback, ...args) {
		return this.on('blur', callback, ...args);
	}

	async resize(callback, ...args) {
		return this.on('resize', callback, ...args);
	}

	async updateready(callback, ...args) {
		return this.on('updateready', ...args);
	}

	async load(callback, ...args) {
		this.on('load', callback, ...args);
		if (document.readyState === 'complete') {
			document.dispatchEvent(new Event('load'));
		}
		return this;
	}

	async unload(callback, ...args) {
		return this.on('unload', callback, ...args);
	}

	async beforeunload(callback, ...args) {
		return this.on('beforeunload', callback, ...args);
	}

	async abort(callback, ...args) {
		return this.on('abort', callback, ...args);
	}

	async error(callback, ...args) {
		return this.on('error', callback, ...args);
	}

	async scroll(callback, ...args) {
		return this.on('scroll', ...args);
	}

	async drag(callback, ...args) {
		return this.on('drag', callback, ...args);
	}

	async offline(callback, ...args) {
		return this.on('offline', callback, ...args);
	}

	async online(callback, ...args) {
		return this.on('online', callback, ...args);
	}

	async hashchange(callback, ...args) {
		return this.on('hashchange', callback, ...args);
	}

	/*visibilitychange(callback) {
		return this.on('visibilitychange', callback);
	}*/

	async popstate(callback, ...args) {
		return this.on('popstate', callback, ...args);
	}

	async pagehide(callback, ...args) {
		return this.on('pagehide', callback, ...args);
	}

	async watch(watching, options = [], attributeFilter = []) {
		/*https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver*/
		const watcher = new MutationObserver(mutations => {
			mutations.forEach(mutation => watching[mutation.type].call(mutation));
		});
		const obs = Object.keys(watching).concat(options).reduce((watch, event) => {
			watch[event] = true;
			return watch;
		}, {attributeFilter});
		return this.each(el => watcher.observe(el, obs));
	}

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver
	 */
	async intersect(callback, options = {}) {
		const observer = new IntersectionObserver(callback, options);
		return this.each(node => observer.observe(node));
	}

	async css(props = {}) {
		return this.each(node => {
			Object.keys(props).forEach(prop => {
				node.style.setProperty(prop, props[prop]);
			});
		});
	}
}

function $(selector, parent = document) {
	return new zQ(selector, parent);
}

const ENDPOINTS = {
	facebook:   'https://www.facebook.com/sharer/sharer.php',
	twitter:     'https://twitter.com/intent/tweet/',
	googlePlus: 'https://plus.google.com/share/',
	linkedIn:   'https://www.linkedin.com/shareArticle/',
	pinterest:   'https://www.pinterest.com/pin/create/button/',
	reddit:     'https://www.reddit.com/submit/'
};

function getDescription(base = document.head) {
	let description = base.querySelector('[itemprop="description"], meta[name="description"]');
	if (description instanceof HTMLElement) {
		return description.hasAttribute('content')
			? description.getAttribute('content')
			: description.textContent;
	} else {
		return '';
	}
}

function getKeywords(base = document.head) {
	let keywords = base.querySelector('[itemprop="keywords"], meta[name="keywords"]');
	if (keywords instanceof HTMLElement) {
		return keywords.hasAttribute('content')
			? keywords.getAttribute('content').split(',')
			: keywords.textContent.split(',');
	} else {
		return [];
	}
}

class SocialShare {
	static get facebook() {
		return SocialShare.getFacebook();
	}

	static get email() {
		return `mailto:?subject=${encodeURIComponent(document.title)}&body=${location.href}`;
	}

	static get twitter() {
		return SocialShare.getTwitter();
	}

	static get googlePlus() {
		return SocialShare.getGooglePlus();
	}

	static get linkedIn() {
		return SocialShare.getLinkedIn();
	}

	static get pinterest() {
		return SocialShare.getPinterest();
	}

	static get reddit() {
		return SocialShare.getReddit();
	}

	static getFacebook(href = location.href) {
		let url = new URL(ENDPOINTS.facebook);
		url.searchParams.set('u', href);
		return url;
	}

	static getTwitter(href = location.href, {
		text     = '',
		via      = null,
		hashtags = getKeywords()
	} = {}) {
		let url = new URL(ENDPOINTS.twitter);
		url.searchParams.set('text', text);
		url.searchParams.set('url', href);
		if (typeof via === 'string') {
			url.searchParams.set('via', via);
		}
		if (hashtags.length > 0) {
			url.searchParams.set('hashtags', hashtags.join(','));
		}
		return url;
	}

	static getGooglePlus(href = location.href) {
		let url = new URL(ENDPOINTS.googlePlus);
		url.searchParams.set('url', href);
		return url;
	}

	static getLinkedIn(href = location.href, {
		title   = document.title,
		summary = getDescription(),
		mini    = 'true'
	} = {}) {
		let url = new URL(ENDPOINTS.linkedIn);
		url.searchParams.set('mini', mini);
		url.searchParams.set('url', href);
		url.searchParams.set('title', title);
		url.searchParams.set('summary', summary);
		return url;
	}

	static getPinterest(href = location.href, {
		media       = null,
		description = getDescription(),
		hashtags    = getKeywords(),
	} = {}) {
		let url = new URL(ENDPOINTS.pinterest);
		url.searchParams.set('url', href);
		if (typeof media === 'string') {
			url.searchParams.set('media', media);
		}
		url.searchParams.set('description', description);
		if (hashtags.length > 0) {
			url.searchParams.set('hashtags', hashtags.join(','));
		}
		return url;
	}

	static getReddit(href = location.href) {
		let url = new URL(ENDPOINTS.reddit);
		url.searchParams.set('url', href);
		return url;
	}

	static openPopup(url, {
		title      = document.title,
		height     = 600,
		width      = 600,
		left       = 0,
		top        = 0,
		menubar    = 'no',
		toolbar    = 'no',
		resizable  = 'yes',
		scrollbars = 'yes'
	} = {}) {
		return window.open(
			url,
			title,
			`menubar=${menubar},toolbar=${toolbar},resizable=${resizable},scrollbars=${scrollbars},width=${width},height=${height},left=${left},top=${top}`
		);
	}
}

/**
 * HTML API using data-* attributes
 */
function show() {
	const target = document.querySelector(this.dataset.show);
	target.show();
}

function showModal() {
	const target = document.querySelector(this.dataset.showModal);
	target.showModal();
}

function close() {
	const target = document.querySelector(this.dataset.close);
	if (this.dataset.hasOwnProperty('returnValue')) {
		target.close(this.dataset.returnValue);
	} else {
		target.close();
	}
}

function scrollTo() {
	const target = document.querySelector(this.dataset.scrollTo);
	target.scrollIntoView({
		behaviour: 'smooth',
		block: 'start'
	});
}

function remove() {
	const targets = document.querySelectorAll(this.dataset.remove);
	targets.forEach(target => target.remove());
}

function fullscreen() {
	document.querySelector(this.dataset.fullscreen).requestFullscreen();
}



function toggleHidden() {
	document.querySelectorAll(this.dataset.toggleHidden).forEach(el => {
		el.hidden = ! el.hidden;
	});
}

function socialShare() {
	if (this.dataset.socialShare in SocialShare) {
		SocialShare.openPopup(`${SocialShare[this.dataset.socialShare]}`);
	}
}

const observer = new IntersectionObserver(lazyLoad, {rootMargin: '500px 0px 0px 0px'});

function infiniteScroll(entries, observer) {
	entries.filter(entry => entry.isIntersecting).forEach(async entry => {
		observer.unobserve(entry.target);
		const url = new URL(entry.target.dataset.infiniteScroll, location.origin);
		try {
			const resp = await fetch(url);
			if (url.searchParams.has('page')) {
				url.searchParams.set('page', parseInt(url.searchParams.get('page')) + 1);
				entry.target.dataset.infiniteScroll = url;
			}
			if (resp.ok) {
				const parser = new DOMParser();
				const html = await resp.text();
				const doc = parser.parseFromString(html, 'text/html');

				if (url.hash !== '') {
					entry.target.before(doc.getElementById(url.hash.substring(1)));
				} else {
					entry.target.before(...doc.body.childNodes);
				}
				observer.observe(entry.target);
			} else {
				throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
			}
		} catch (error) {
			console.error(error);
			observer.observe(entry.target);
		}
	});
}

function lazyLoad(entries, observer) {
	entries.filter(entry => entry.isIntersecting).forEach(async entry => {
		try {
			const url = new URL(entry.target.dataset.loadFrom, location.href);
			const resp = await fetch(url);
			if (resp.ok) {
				const parser = new DOMParser();
				const html = await resp.text();
				const content =  parser.parseFromString(html, 'text/html');
				entry.target.append(...content.body.childNodes);
			} else {
				throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
			}
		} catch (error) {
			console.error(error);
		} finally {
			observer.unobserve(entry.target);
			delete entry.target.dataset.loadFrom;
		}
	});
}

function toggleDetails() {
	const details = this.closest('details');
	details.open != details.open;
}

const events = {
	attributes: function() {
		switch(this.attributeName) {
		case 'data-remove':
			if (this.target.dataset.hasOwnProperty('remove')) {
				this.target.addEventListener('click', remove);
			} else {
				this.target.removeEventListener('click', remove);
			}
			break;
		case 'data-show-modal':
			if (this.target.dataset.hasOwnProperty('showModal')) {
				this.target.addEventListener('click', showModal);
			} else {
				this.target.removeEventListener('click', showModal);
			}
			break;
		case 'data-show':
			if (this.target.dataset.hasOwnProperty('show')) {
				this.target.addEventListener('click', show);
			} else{
				this.target.removeEventListener('click', show);
			}
			break;
		case 'data-close':
			if (this.target.dataset.hasOwnProperty('close')) {
				this.target.addEventListener('click', close);
			} else {
				this.target.removeEventListener('click', close);
			}
			break;
		case 'data-toggle-hidden':
			if (this.target.dataset.hasOwnProperty('toggleHidden')) {
				this.target.addEventListener('click', toggleHidden);
			} else {
				this.target.removeEventListener('click', toggleHidden);
			}
			break;
		case 'data-social-share':
			if (this.target.dataset.hasOwnProperty('socialShare')) {
				this.target.addEventListener('click', socialShare);
			} else {
				this.target.removeEventListener('click', socialShare);
			}
			break;
		case 'data-fullscreen':
			if (this.target.dataset.hasOwnProperty('fullscreen')) {
				this.target.addEventListener('click', fullscreen);
			} else {
				this.target.removeEventListener('click', fullscreen);
			}
			break;
		case 'data-scroll-to':
			if (this.target.dataset.hasOwnProperty('scrollTo')) {
				this.target.addEventListener('click', scrollTo);
			} else {
				this.target.removeEventListener('click', scrollTo);
			}
			break;
		default:
			throw new Error(`Unhandled attribute change [${this.attributeName}]`);

		}
	},
	childList: function() {
		$(this.addedNodes).each(node => {
			if (node.nodeType === Node.ELEMENT_NODE) {
				init(node);
			}
		});
	}
};
const filter = [
	'data-remove',
	'data-show-modal',
	'data-show',
	'data-close',
	'data-toggle-hidden',
	'data-social-share',
	'data-fullscreen',
];

const options = [
	'subtree',
	'attributeOldValue'
];

function init(base = document.body) {
	$('[data-show]', base).click(show);
	$('[data-show-modal]', base).click(showModal);
	$('[data-close]', base).click(close);
	$('[data-remove]', base).click(remove);
	$('[data-toggle-hidden]', base).click(toggleHidden);
	// $('[data-schema-content]', base).each(importSchema);
	$('[data-social-share]', base).click(socialShare);
	$('[data-fullscreen]', base).click(fullscreen);
	$('[data-scroll-to]', base).click(scrollTo);
	$('[data-infinite-scroll]', base).intersect(infiniteScroll);
	$('[data-load-from]', base).each(node => observer.observe(node));

	if (document.createElement('details') instanceof HTMLUnknownElement) {
		$('details > summary').click(toggleDetails);
	}
}

var deprefix = function() {
	if (!('Notification' in window)) {
		window.Notification = window.notifications || window.webkitNotifications || window.oNotifications || window.msNotifications || false;
	}
	if (!('indexedDB' in window)) {
		window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || false;
	}
	if (!('hidden' in document)) {
		document.hidden = document.webkitHidden || document.msHidden || document.mozHidden || false;
	}
	if (!('visibilityState' in document)) {
		document.visibilityState = document.webkitVisibilityState || document.msVisibilityState || document.mozVisibilityState || 'visible';
	}
	if (!('fullscreenElement' in document)) {
		document.fullscreenElement = document.mozFullScreenElement || document.webkitFullscreenElement || false;
	}
	if (!('requestAnimationFrame' in window)) {
		window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;
	}
	if (!('exitFullscreen' in Document.prototype)) {
		Document.prototype.exitFullscreen = document.mozCancelFullScreen || document.webkitCancelFullScreen || document.msCancelFullScreen || false;
	}
	if (!('requestFullscreen' in HTMLElement.prototype)) {
		HTMLElement.prototype.requestFullScreen = HTMLElement.prototype.mozRequestFullScreen || HTMLElement.prototype.webkitRequestFullScreen || false;
	}
};

if (document.createElement('dialog') instanceof HTMLUnknownElement && !HTMLElement.prototype.hasOwnProperty('open')) {
	HTMLElement.prototype.show = function() {
		this.open = true;
	};

	HTMLElement.prototype.close = function(returnValue = null) {
		this.open = false;
		if (this.tagName === 'DIALOG') {
			this.dispatchEvent(new CustomEvent('close', {detail: returnValue}));
		}
	};

	Object.defineProperty(HTMLElement.prototype, 'open', {
		set: function(open) {
			if (open) {
				this.setAttribute('open', '');
			} else {
				this.removeAttribute('open');
				if (this.tagName === 'DIALOG') {
					this.classList.remove('modal');
					const next = this.nextElementSibling;
					if (next instanceof HTMLElement && next.matches('.backdrop')) {
						next.remove();
					}
				}
			}
		},
		get: function() {
			return this.hasAttribute('open');
		}
	});
}
if (! document.createElement('dialog').hasOwnProperty('showModal')) {
	HTMLElement.prototype.showModal = function() {
		this.open = true;
		this.classList.add('modal');
		const backdrop = document.createElement('div');
		backdrop.classList.add('backdrop');
		this.after(backdrop);
	};
}

function supports(type) {
	/*Feature detection. Returns boolean value of suport for type*/
	/**
	* A series of tests to determine support for a given feature
	* Defaults to testing support for an element of tag (type)
	* Which works by testing if the browser considers it unknown element type
	*/
	if (typeof type !== 'string') {
		return false;
	}

	try {
		switch (type.toLowerCase()) {
		case 'queryselectorall':
			return ('querySelectorAll' in document);

		case 'svg':
			return (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Shape', '1.1'));

		case 'dataset':
			return ('DOMStringMap' in window);

		case 'htmlimports':
			return ('import' in document.createElement('link'));

		case 'geolocation':
			return ('geolocation' in navigator);

		case 'connectivity':
			return ('onLine' in navigator);

		case 'visibility':
			return ('visibilityState' in document) || ('webkitVisibilityState' in document);

		case 'validity':
			return ('validity' in document.createElement('input'));

		case 'fonts':
			return ('CSSFontFaceRule' in window);

		case 'csssupports':
			return (('CSS' in window) && ('supports' in CSS));

		case 'listeners':
			return ('addEventListener' in window);

		case 'animations':
			return ((supports('csssupports')
					&& (CSS.supports('animation', 'name')
					|| CSS.supports('-webkit-animation', 'name'))
				)
					|| 'animation' in document.body.style
					|| 'webkitAnimation' in document.body.style
			);

		case 'transitions':
			return ((supports('csssupports')
				&& (CSS.supports('transition', 'none')
					|| CSS.supports('-webkit-transition', 'none'))
				)
				|| 'transition' in document.body.style
				|| 'webkitTransition' in document.body.style
			);

		case 'cssgradients':
			return (supports('csssupports')
					&& CSS.supports('background-image', 'linear-gradient(red,red)'))
					|| (function() {
						var el = document.createElement('a');
						el.style.backgroundImage = 'linear-gradient(red, red)';
						return (!!el.style.backgroundImage);
					})();

		case 'notifications':
			return ('notifications' in window || 'Notification' in window);

		case 'applicationcache':
			return ('applicationCache' in window);

		case 'indexeddb':
			return ('indexedDB' in window);

		case 'fullscreen':
			return ('cancelFullScreen' in document);

		case 'workers':
			return ('Worker' in window);

		case 'promises':
			return ('Promise' in window);

		case 'cssmatches':
			return ('sessionStorage' in window && sessionStorage.hasOwnProperty('MatchesPre')) ||
				[':matches', ':any', ':-moz-any', ':-webkit-any'].some(pre => {
					try {
						if (document.querySelector(`${pre}(body)`) === document.body) {
							sessionStorage.setItem('MatchesPre', pre);
							return true;
						} else {
							return false;
						}
					} catch (e) {
						return false;
					}
				});

		case 'ajax':
			return ('XMLHttpRequest' in window);

		case 'cssvars':
			return (supports('csssupports') && CSS.supports('--x', 'x'));

		case 'formdata':
			return ('FormData' in window);

		case 'classlist':
			return ('DOMTokenList' in window);

		case 'localstorage':
			return ('localStorage' in window);

		case 'sessionstorage':
			return ('sessionStorage' in window);

		default:
			return ! (document.createElement(type) instanceof HTMLUnknownElement);
		}
	} catch(e) {
		return false;
	}
}
function supportsAsClasses(...feats) {
	if (feats instanceof Array) {
		feats.forEach(feat => {
			supports(feat)
				? document.documentElement.classList.add(feat)
				: document.documentElement.classList.add(`no-${feat}`);
		});
	}
}

deprefix();

async function registerServiceWorker(el) {
	try {
		if (! Navigator.prototype.hasOwnProperty('serviceWorker')) {
			throw new Error('Service worker not supported');
		}

		const url = new URL(el.dataset.serviceWorker, location.origin);
		const reg = await navigator.serviceWorker.register(url);

		if(reg.installing) {
			console.log('Service worker installing');
		} else if(reg.waiting) {
			console.log('Service worker installed');
		} else if(reg.active) {
			console.log('Service worker active');
		}
	} catch (error) {
		console.error(error);
	}
}

async function readyHandler() {
	const $doc = $(document.documentElement);
	$doc.replaceClass('no-js', 'js');
	$doc.toggleClass('offline', ! navigator.onLine);
	$doc.watch(events, options, filter);
	$doc.keypress(event => event.key === 'Escape' && $('dialog[open]').close());
	supportsAsClasses(...document.documentElement.dataset.supportTest.split(',').map(test => test.trim()));

	$('[data-service-worker]').each(registerServiceWorker).catch(console.error);

	init();

	// const resp = await fetch(new URL('portfolio.json', location.href));
	// if (resp.ok) {
	// 	const main = document.querySelector('main');
	// 	const template = document.getElementById('project-template');
	// 	const projects = await resp.json();
	// 	projects.forEach(async project => {
	// 		const card = template.content.cloneNode(true);
	// 		await $('[itemtype]', card).attr({itemscope: true});
	// 		await $('[itemprop="name"]', card).text(project.name);
	// 		await $('[itemprop="applicationCategory"]', card).text(project.applicationCategory);
	// 		await $('[itemprop="keywords"]', card).text(project.keywords);
	// 		await $('[itemprop="screenshot"]', card).attr({src: project.screenshot});
	// 		await $('[itemprop="description"]', card).text(project.description);
	// 		await $('[itemprop="url"]', card).attr({href: project.url});
	// 		await $('[itemprop="operatingSystem"]', card).attr({content: project.operatingSystem});
	// 		main.append(card);
	// 	});
	// } else {
	// 	throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
	// }
}

$(self).ready(readyHandler, {once: true});

}());
//# sourceMappingURL=index.min.js.map
